Remote mux resize: traffic reduction assessment (since d6448296)

Summary
- The new client-side changes in `wezterm-client` add: (1) redundant-resize shortâ€‘circuiting, (2) selective invalidation on resize, and (3) a 100 ms debounce before sending the resize RPC to the server. Together, these changes can materially reduce total updates emitted by the remote mux and processed by the GUI, especially during window drag resizes that previously produced storms of identical events.
- Additional opportunities exist to further reduce updates at the server and client boundaries by coalescing size changes, avoiding full resyncs for TabResized, and pausing/pacing render polling during active resize.
- Below are concrete instrumentation points to confirm effectiveness, with suggested counters and logs at precise code locations.

What changed (relevant to resize/update traffic)
- ClientPane redundant-resize shortâ€‘circuiting: `wezterm-client/src/pane/clientpane.rs:389`
  - Early return if cols/rows/pixels unchanged, with diagnostic log: "RESIZE STORM: Redundant resize".
  - Expected effect: suppress repeated local resize work and prevent additional remote resizes for identical dimensions.
- Debounced resize towards server (100 ms): `wezterm-client/src/pane/clientpane.rs:438`
  - Schedules a timer then sends the single latest size to the server.
  - Expected effect: coalesce many UI events into one server resize â†’ fewer TabResized notifications and fewer render deltas emitted by the server.
- Selective invalidation on resize: `wezterm-client/src/pane/renderable.rs:444` via `make_viewport_stale(100)`
  - Replaces `make_all_stale()` with viewport+margin invalidation.
  - Expected effect: fewer stale rows â†’ fewer line fetches (clientâ†’server) â†’ smaller/more targeted `GetPaneRenderChangesResponse` hydration on the GUI.
- Fetch generation field added: `wezterm-client/src/pane/renderable.rs:84`
  - Increments on `make_viewport_stale()`. Currently only used for logging; not yet used to cancel inâ€‘flight fetches.
- Serverâ†’client TabResized handling triggers a resync today: `wezterm-client/src/client.rs:300,314`
  - When the server notifies `TabResized`, the client logs and calls `ClientDomain::resync()`. With the clientâ€‘side redundant-resize check, resizes that resolve to identical size will be ignored, which should dampen any potential feedback loop.

Does this reduce total update traffic from the remote mux to the GUI?
- Yes, via three mechanisms:
  - Debounce: The client only sends one resize RPC to the server for a burst of window-size events. The server therefore performs layout once and emits at most one `MuxNotification::TabResized` per debounce interval instead of one per event.
  - Redundant-resize shortâ€‘circuit: Prevents reâ€‘sending a resize that doesnâ€™t actually change dimensions. This blocks spurious server resizes and their corresponding notifications.
  - Selective invalidation: Limits the number of lines that transition into the â€œfetchingâ€ path after a resize. Fewer requested lines means fewer/lighter `GetPaneRenderChangesResponse` payloads arriving at the GUI after the resize.
- Caveats/notes:
  - `fetch_generation` isnâ€™t currently used to cancel inâ€‘flight fetches. If many fetches start during a resize, some redundant results may still arrive; adding a guard to drop stale fetch completions would further reduce traffic and GUI work.
  - `Pdu::TabResized` still triggers a `resync()` on the client. While necessary for topology changes, this can be made cheaper (see Alternatives) so that server notifications donâ€™t imply heavier client traffic than needed.

Alternatives to further reduce updates generated by resizes
- Server-side coalescing of TabResized notifications
  - Where: `mux/src/tab.rs:911,1000,1182,1258,1374` (multiple notify sites)
  - Strategy: Track last notified size per `TabId` and only notify on actual change; optionally debounce notifications (e.g., 50â€“100 ms) to collapse repositioning/split adjustments into one notification.
- Server-side resize epoch and drop/interlock
  - Assign an increasing resize_epoch on each `Tab::resize`, include it in outgoing deltas. Any work tied to older epochs is skipped. This prevents cascades from intermediate states if the client is still polling.
- Client-side: avoid full resync on TabResized
  - Current: `wezterm-client/src/client.rs:300,314` causes `ClientDomain::resync()`.
  - Alternative: issue a light-weight â€œsizes-onlyâ€ refresh or a targeted pane render change poll, avoiding full structure/ID reconciliation unless IDs changed.
- Client-side: pause or slow render polling during active resize
  - Temporarily extend the poll interval while resize is in progress, resuming normal cadence after debounce fires. This reduces `GetPaneRenderChanges` traffic during the resize burst.
- Client-side: enforce fetch-cancellation using generation
  - Add generation tokens to `schedule_fetch_lines` and to the completion path so completed fetches with stale generation are elided.
- Server-side: size change commit point
  - When multiple resizes arrive in quick succession, only recompute layout once (lastâ€‘writerâ€‘wins) and emit a single delta snapshot to the client.

How to instrument the remote mux (and related client points)
- Goals: Count and size the messages that flow during resizes; prove reductions after these changes. Suggested counters are perâ€‘tab and perâ€‘window where applicable.

Server (mux)
- Count TabResized notifications
  - Where to instrument: every `Mux::try_get().map(|mux| mux.notify(MuxNotification::TabResized(self.id)))` site in `mux/src/tab.rs:911,1000,1182,1258,1374`.
  - Add a perâ€‘TabId atomic counter and a `last_notified_size`. Log on change and periodically summarize (e.g., at INFO every second while resizes occur):
    - tab_id, new colsÃ—rows, count since last log, total since start.
- Count GetPaneRenderChanges responses and payload sizes
  - Where: `wezterm-mux-server-impl/src/sessionhandler.rs:56,131,681,760,996` paths handling `GetPaneRenderChanges`.
  - Record: number of responses, total bytes serialized, number of dirty lines included, and max/min across a sliding window.
- Optional: add a resize_epoch
  - In `mux/src/tab.rs:610` (Tab::resize) increment `self.resize_epoch` and include it in render-change responses and `TabResized`. Log epoch transitions and skip emitting if the epoch has already moved on.

Client (GUI side) to correlate
- Log duplicate-resize early return counts
  - Already present: `ðŸ”´ RESIZE STORM` in `wezterm-client/src/pane/clientpane.rs:402`.
  - Summarize: count per second and final tally when debounce fires.
- Log debounce decisions
  - Already present: "Scheduling deferred resize" and "Sending deferred resize" in `clientpane.rs:436,443`.
- Count resyncs triggered by TabResized
  - Where: `wezterm-client/src/client.rs:300,314` paths. Add a counter or log with tab_id and size (if available) to correlate with server notifications.

Quick instrumentation sketches
- Server: TabResized counter/log
  - File: `mux/src/tab.rs:1182`
    - Add: `static RESIZED_NOTIF: std::sync::atomic::AtomicU64` per tab (better: store in TabInner), compare against `last_notified_size`, increment and `log::info!("tab={} size={}x{} notif_count={} epoch={}", ...)`.
- Server: render-change size logging
  - File: `wezterm-mux-server-impl/src/sessionhandler.rs:131`
    - After building `GetPaneRenderChangesResponse`, compute serialized length or number of lines: `resp.lines.len()`, `dirty.len()`, and `serde_json::to_vec(&resp)?.len()` (only when RUST_LOG=trace or behind a `WEZTERM_DEBUG_MUX_STATS=1` env flag) and log.
- Client: resync counter
  - File: `wezterm-client/src/client.rs:300`
    - Add `log::debug!("TabResized -> resync (tab_id={})")` and keep a moving counter to confirm it drops after fixes.

Validating effectiveness
- Enable logs and reproduce a resize drag on a remote session:
  - `RUST_LOG=info,wezterm_client=debug,wezterm_mux_server_impl=debug,wezterm_mux=debug`
  - Observe:
    - Server: TabResized notifications per second should collapse to ~1 per debounce window.
    - Server: `GetPaneRenderChangesResponse` count and total bytes should drop during active resize vs. prior build.
    - Client: Many window-size events, but only one "Sending deferred resize" per burst; redundant-resize early-returns should be nonâ€‘zero, confirming suppression.
- Suggested metrics to capture before/after:
  - TabResized notifications per drag gesture.
  - Count and bytes of GetPaneRenderChanges responses over a 5 s resize test.
  - Client resync count in the same interval.

Recommendations / next increments
- Promote fetch_generation to a real cancellation token: carry it through `schedule_fetch_lines` and ignore fetch completions from prior generations.
- Replace full resync on `Pdu::TabResized` with a targeted size-sync and render poll; full resync only when topology changes.
- Add serverâ€‘side lastâ€‘writerâ€‘wins resize coalescing with optional debounce to guarantee at-most-one notification per short interval.

Conclusion
- The landed client changes will reduce redundant updates: they avoid reâ€‘issuing identical resizes, coalesce events via debounce, and shrink the set of lines considered dirty postâ€‘resize. These should substantially reduce the traffic emitted by the remote mux and processed by the GUI during resize storms. The outlined server/client instrumentation will confirm reductions through concrete counts and byte sizes, and the listed alternatives provide further headroom if additional reductions are desired.

